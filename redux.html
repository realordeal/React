<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>그냥 평범한 리덕스</title>
</head>
<body>
  <h1 id="number">0</h1>
  <button id="increment">+</button>
  <button id="decrement">-</button>
<script src="https://cdnjs.cloudflare.com/ajax/libs/redux/3.6.0/redux.js"></script>
<script src="redux.js"></script>
</body>
</html>
<!-- concat 함수는 선택된 여러개의 범위 또는 여러개의 텍스트를 하나의 문자열로 결합하는 함수이다.
 -->
<!-- 리덕스의 3가지 규칙
  리덕스를 프로젝트에서 사용하게 될 때 알아둬야 할 3가지 규칙이 있다.
  1. 하나의 애플리케이션 안에는 하나의 스토어가 있다.
    하나의 애플리케이션에선 단 한개의 스토어를 만들어서 사용한다. 사실 권장되지는 않는다. 여러개의 스토어를
    를 만들고 싶다면 만들 수는 있다. 특정 업데이트가 너무 빈번하게 일어나거나, 애플리케이션의 특정 부분을 환전히
    분리시키게 될 때 그렇게 여러개의 스토어를 만들 수도 있다. 하지만 그렇게 하면 개발 도구를 활요하지 못하게 된다.

  2. 상태는 읽기 전용이다.
    리액트에서 state를 업데이트 해야 할 때 setState를 사용하고 배열을 업데이트 해야 할 때는 배열 자체에 push를
    직접 하지 않고, concat같은 함수를 사용하여 기존의 배열은 수정하지 않고 새로운 배열을 만들어서 교체하는 방식
    으로 업데이트를 한다. 엄청 깊은 구조로 되어있는 객체를 업데이트를 할 때도 마찬가지로 기존의 객체는 건들이지
    않고 Object.assign을 사용하거나 spread 연산자 (...)를 사용하여 업데이트 하곤 한다.
    리덕스에서도 마찬가지이다. 기존의 상태는 건들이지 않고 새로운 상태를 생성하여 업데이트 해주는 방식으로 해주면
    나중에 개발자 도구를 통해서 뒤로 돌릴 수도 있고 다시 앞으로 돌릴 수도 있다.
    리덕스에서 불변성을 유지해야 하는 이유는 내부적으로 데이터가 변경 되는 것을 감지하기 위하여 shallow equality검사를 하기 때문이다.
    이를 통하여 객체의 변화를 감지 할 때 객체의 깊숙한 안쪽까지 비교를 하는 것이 아니라 겉핥기 식으로 비교를 하여 좋은 성능을 유지할 수 있는 것이다.
    Immutable.js를 사용하여 불변성을 유지하며 상태를 관리하게 된다. -->
